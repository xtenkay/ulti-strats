// src/index.ts
import {
  loadShikiTheme,
  ExpressiveCode,
  ExpressiveCodeTheme,
  ExpressiveCodeBlock
} from "expressive-code";
import { toHtml, visit } from "expressive-code/hast";
export * from "expressive-code";
async function createRenderer(options = {}) {
  const deprecatedOptions = options;
  if (deprecatedOptions.theme && !options.themes) {
    options.themes = Array.isArray(deprecatedOptions.theme) ? deprecatedOptions.theme : [deprecatedOptions.theme];
    delete deprecatedOptions.theme;
  }
  const { themes, ...ecOptions } = options;
  const loadedThemes = themes && await Promise.all(
    (Array.isArray(themes) ? themes : [themes]).map(async (theme) => {
      const mustLoadTheme = theme !== void 0 && !(theme instanceof ExpressiveCodeTheme);
      const optLoadedTheme = mustLoadTheme ? new ExpressiveCodeTheme(typeof theme === "string" ? await loadShikiTheme(theme) : theme) : theme;
      return optLoadedTheme;
    })
  );
  const ec = new ExpressiveCode({
    themes: loadedThemes,
    ...ecOptions
  });
  const baseStyles = await ec.getBaseStyles();
  const themeStyles = await ec.getThemeStyles();
  const jsModules = await ec.getJsModules();
  return {
    ec,
    baseStyles,
    themeStyles,
    jsModules
  };
}
var remarkExpressiveCode = (...settings) => {
  const options = settings[0] ?? {};
  const { tabWidth = 2, getBlockLocale, customCreateRenderer, customCreateBlock } = options;
  let asyncRenderer;
  const renderBlockToHtml = async ({
    codeBlock,
    renderer,
    addedStyles,
    addedJsModules
  }) => {
    const { ec, baseStyles, themeStyles, jsModules } = renderer;
    const { renderedGroupAst, styles } = await ec.render(codeBlock);
    const extraElements = [];
    const stylesToPrepend = [];
    if (baseStyles && !addedStyles.has(baseStyles)) {
      addedStyles.add(baseStyles);
      stylesToPrepend.push(baseStyles);
    }
    if (themeStyles && !addedStyles.has(themeStyles)) {
      addedStyles.add(themeStyles);
      stylesToPrepend.push(themeStyles);
    }
    for (const style of styles) {
      if (addedStyles.has(style))
        continue;
      addedStyles.add(style);
      stylesToPrepend.push(style);
    }
    if (stylesToPrepend.length) {
      extraElements.push({
        type: "element",
        tagName: "style",
        properties: {},
        children: [{ type: "text", value: [...stylesToPrepend].join("") }]
      });
    }
    jsModules.forEach((moduleCode) => {
      if (addedJsModules.has(moduleCode))
        return;
      addedJsModules.add(moduleCode);
      extraElements.push({
        type: "element",
        tagName: "script",
        properties: { type: "module" },
        children: [{ type: "text", value: moduleCode }]
      });
    });
    renderedGroupAst.children.unshift(...extraElements);
    const htmlContent = toHtml(renderedGroupAst);
    return htmlContent;
  };
  const transformer = async (tree, file) => {
    const nodesToProcess = [];
    visit(tree, "code", (code, index, parent) => {
      if (index === null || !parent)
        return;
      nodesToProcess.push([parent, code]);
    });
    if (nodesToProcess.length === 0)
      return;
    if (asyncRenderer === void 0) {
      asyncRenderer = (customCreateRenderer ?? createRenderer)(options);
    }
    const renderer = await asyncRenderer;
    const addedStyles = /* @__PURE__ */ new Set();
    const addedJsModules = /* @__PURE__ */ new Set();
    for (let groupIndex = 0; groupIndex < nodesToProcess.length; groupIndex++) {
      const [parent, code] = nodesToProcess[groupIndex];
      let normalizedCode = code.value;
      if (tabWidth > 0)
        normalizedCode = normalizedCode.replace(/\t/g, " ".repeat(tabWidth));
      const input = {
        code: normalizedCode,
        language: code.lang || "",
        meta: code.meta || "",
        parentDocument: {
          sourceFilePath: file.path,
          documentRoot: tree,
          positionInDocument: {
            groupIndex,
            totalGroups: nodesToProcess.length
          }
        }
      };
      if (getBlockLocale) {
        input.locale = await getBlockLocale({ input, file });
      }
      const codeBlock = customCreateBlock ? await customCreateBlock({ input, file }) : new ExpressiveCodeBlock(input);
      const blockHtml = await renderBlockToHtml({ codeBlock, renderer, addedStyles, addedJsModules });
      const html = {
        type: "html",
        value: blockHtml
      };
      parent.children.splice(parent.children.indexOf(code), 1, html);
    }
  };
  return transformer;
};
var src_default = remarkExpressiveCode;
export {
  createRenderer,
  src_default as default
};
//# sourceMappingURL=index.js.map